/**
 ******************************************************************************
 * @file    main.c
 * @author  Logan Vesty
 * @version V1.0.0
 * @date    23-DEC-2021
 * @brief   Main program body
 *******************************************************************************************************
 * Project: ASTM Compression Rig Firmware
 *          The compression rig is used for testing a compressive load on a package for ASTM D4169 
 *          It consists of a Motor, linear scale and Load cell.
 *
 * SW Part#:       
 * HW Platform:    
 * Processor:      RP2040 (Raspberry Pi Pico)
 * Tool chain:     GCC 10.3.1 arm-none-eabi
 * More Info:      
 *          This firware uses modified example codes from the raspberry pi pico git, refer bellow
 *          https://github.com/raspberrypi/pico-examples/tree/master/pio/quadrature_encoder
 *          https://github.com/raspberrypi/pico-examples/blob/master/uart/uart_advanced/uart_advanced.c
 *
 ********************************************************************************************************
 */

//Header Files
#include <stdio.h>
#include "pico/stdlib.h"
#include "pico/multicore.h"
#include "hardware/pio.h"
#include "hardware/timer.h"
#include "hardware/uart.h"
#include "hardware/irq.h"
#include "hardware/pwm.h"
#include "pico/time.h"
#include "main.h"

//Header files generated by CMakeLists
#include "quadrature_encoder.pio.h"


//Global Variables 
//The force is written by core1 and read by core0,
//Seems to work fine for now, this is happening frequently and potentially could cause issues TODO: setup queue 
char g_force_string[8];
float g_force;
int g_zero_position_counts;
int g_step_pwm_cycle_time;
float g_preload = 0.0;
float g_load = 0.0;
uint32_t g_start_time_ms;
uint32_t g_preload_start_time;
uint32_t g_load_start_time;
enum states state = STATE_IDLE;
struct repeating_timer get_commands_timer;


//Main Entry Point, Core 0
int main() {

    //Quadrature Encoding PIO setup
    uint offset = pio_add_program(ENCODER_PIO, &quadrature_encoder_program);
    quadrature_encoder_program_init(ENCODER_PIO, ENCODER_SM, offset, ENCODER_PIN_AB, 0);

    //USB Serial setup 
    stdio_init_all();

    //Setup Stepper
    gpio_set_function(STEP_PULSE_PIN, GPIO_FUNC_PWM);
    pwm_set_wrap(STEP_PWM_SLICE, g_step_pwm_cycle_time);
    pwm_set_chan_level(STEP_PWM_SLICE, STEP_PWM_CHANNEL, STEP_PULSE_PWN_WIDTH);
    pwm_set_clkdiv(STEP_PWM_SLICE,STEP_PULSE_PWM_CLKDIV);
    gpio_init(STEP_DIR_PIN);
    gpio_set_dir(STEP_DIR_PIN, GPIO_OUT);
    gpio_init(STEP_EN_PIN);
    gpio_set_dir(STEP_EN_PIN, GPIO_OUT);
    gpio_put(STEP_EN_PIN, 0);

    //start core 1
    multicore_launch_core1(core1_main);
    sleep_ms(1000);

    //wait for PC Connection
    while (!stdio_usb_connected())
    {
        tight_loop_contents();
    }

    //Setup Repeating Timer to read pc commands.
    add_repeating_timer_ms(50, get_command, NULL, &get_commands_timer);


    while (1) 
    {
        state_machine();
    }

}

bool get_command(struct repeating_timer *t)
{
    if(state != STATE_PRE_TEST)
    {
        //Get commands from serial
        int command = getchar_timeout_us(10);
        if (command != PICO_ERROR_TIMEOUT)
            command_handler(command);
    }
}

void state_machine()
{
    switch (state)
    {
    
    case STATE_IDLE:
        //Continually send force and position data to app
        output_values(0,0);
        sleep_ms(100);
        break;

    case STATE_STARTING:
        g_start_time_ms = to_ms_since_boot(get_absolute_time());
        //Start Motor Down
        pwm_set_wrap(STEP_PWM_SLICE, TEST_SPEED);
        gpio_put(STEP_DIR_PIN, 0);
        pwm_set_enabled(STEP_PWM_SLICE, true);
        state = STATE_PRELOADING;
        break;
    
    case STATE_PRELOADING:
        output_values(to_ms_since_boot(get_absolute_time())-g_start_time_ms, 1);
        if (g_force*1000>=g_preload)
        {
            //Stop Motor
            pwm_set_enabled(STEP_PWM_SLICE, false);
            g_preload_start_time = to_ms_since_boot(get_absolute_time());
            state = STATE_PRELOAD_DELAY;
        }
        break;
    
    case STATE_PRELOAD_DELAY:
        output_values(to_ms_since_boot(get_absolute_time())-g_start_time_ms, 1);
        if(to_ms_since_boot(get_absolute_time()) - g_preload_start_time >= PRELOAD_DELAY)
        {

            //Start Motor
            pwm_set_enabled(STEP_PWM_SLICE, true); 
            state = STATE_LOADING;
        }
        break;

    case STATE_LOADING:
        output_values(to_ms_since_boot(get_absolute_time())-g_start_time_ms, 1);
        if(g_force*1000>=g_load)
        {
            //Stop Motor
            pwm_set_enabled(STEP_PWM_SLICE, false);
            g_load_start_time = to_ms_since_boot(get_absolute_time());
            state = STATE_LOAD_DELAY;
        }
        break; 

    case STATE_LOAD_DELAY:
        output_values(to_ms_since_boot(get_absolute_time())-g_start_time_ms, 1);
        if(to_ms_since_boot(get_absolute_time()) - g_load_start_time >= LOAD_DELAY)
        {
            //Move Motor Up
            gpio_put(STEP_DIR_PIN, 1);
            pwm_set_enabled(STEP_PWM_SLICE, true);
            state = STATE_FINISHING;
        }
        break;

    case STATE_FINISHING:
        output_values(to_ms_since_boot(get_absolute_time())-g_start_time_ms, 1);
        if(g_force*1000 < 5)
        {
            pwm_set_enabled(STEP_PWM_SLICE, false);
            state = STATE_QUITTING;
        }
        break;

    case STATE_QUITTING:
        //Stop Motion
        pwm_set_enabled(STEP_PWM_SLICE, false);
        //Reset Variables
        g_preload = 0.0;
        g_load = 0.0;
        g_start_time_ms = 0;
        g_preload_start_time = 0;
        g_load_start_time = 0;
        state = STATE_IDLE;
        break;

    case STATE_PRE_TEST:;

        char preloadArr[7] = {0};
        //float preload;
        char loadArr[7] = {0};
        //float load;
        char ch;
        
        //First get preload value
        for (int i = 0; i < 6; i++)
        {
            preloadArr[i]= getchar();
            //Getting garbage sometimes, only want number or period
            while ((preloadArr[i] < '0' && preloadArr[i]!= '.') || preloadArr[i] > '9' )
            {
                preloadArr[i]= getchar(); 
                if (preloadArr[i]=PICO_ERROR_TIMEOUT) break;
            }
        }
        //Then get load value
        for (int i = 0; i < 6; i++)
        {
            loadArr[i]= getchar();
            //Getting garbage sometimes, only want number or period
            while ((loadArr[i] < '0'&& loadArr[i]!= '.')  || loadArr[i] > '9')
            {
                loadArr[i]= getchar();
                if (loadArr[i]=PICO_ERROR_TIMEOUT) break;
            }
        }
        //convert to float
        sscanf(preloadArr,"%f", &g_preload);
        sscanf(loadArr,"%f", &g_load);
        //relay back to PC
        printf("PreLoad Set to: %.1f N,", g_preload);
        printf("\n");
        printf("Load Set to: %.1f N,", g_load);
        printf("\n");

        //Delay 2 seconds before starting 
        sleep_ms(2000);
        state = STATE_STARTING;
        break;

    default:
        break;
    }


}

//Core 1 Entry point
//Core 1 will handle to UART interface between the Load Cell amplifier 
void core1_main() {

    //Uart1 Setup
    uart_init(uart1, 9600);
    gpio_set_function(HARD_UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(HARD_UART_RX_PIN, GPIO_FUNC_UART);
    uart_set_fifo_enabled(uart1, false);
    // Set up a RX interrupt
    int UART_IRQ = UART1_IRQ;
    irq_set_exclusive_handler(UART_IRQ, on_uart1_rx);
    irq_set_enabled(UART_IRQ, true);
    uart_set_irq_enables(uart1, true, false);

    while (1)
    {
        tight_loop_contents();

    }
        
}

// RX1 interrupt handler
void on_uart1_rx() 
{

    //check for data on rx buffer
    while (uart_is_readable(uart1)) {

        //get character from buffer, wait for '\n' to signify start of force number.
        uint8_t ch = uart_getc(uart1);
        if (ch == '\n')
        {
            //ignore the first 5 chars, we dont need this data
            for (int i = 0; i < 6; i++)
            {
                ch = uart_getc(uart1);
            }
            //get 7 charcters of force data 
            //ch = uart_getc(uart1);
            for (int i = 0; i < 8; i++)
            {
                g_force_string[i] = ch;
                ch = uart_getc(uart1);
            }
            
        }

    }

    //convert force string to float
    sscanf(g_force_string,"%f", &g_force);

}

/**
 * @brief  Function map().
 *         used to map value to a new range
 * @param  original number, original number range, new number range 
 * @retval New number
 */
long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


/**
 * @brief  Function output_values().
 *         outputs the Time, Load and Displacement over Serial.
 * @param  time in ms from start of test, test_is_running booleen
 * @retval None
 */
void output_values(uint32_t time, bool test_is_running)
{
        //get current position
        int position_counts = quadrature_encoder_get_count(ENCODER_PIO, ENCODER_SM);
        double position_mm=(position_counts-g_zero_position_counts)*0.005;

        //print time, position and force to serial
        if (test_is_running)
        {
            printf("%u,", time);
            printf("%.3f,", position_mm);
            printf("%.3f\n",g_force*1000);
        }
        else
        {
            printf("$d%.3f", position_mm);
            sleep_ms(20);//add a small delay between sending so the app reads them seprately. A bit lazy.
            printf("$f%.3f",g_force*1000);
        }

}

/**
 * @brief  Function comand_handler().
 *         handles comands sent from the pc app.
 * @param  ch ascii char value to represnt command 
 * @retval none
 */

void command_handler(int ch) 
{
    switch (ch)
    {
        case 's': // Start Test
        {
            state = STATE_PRE_TEST;
            break;
        }

        case '+': //Move motor up
        {
            gpio_put(STEP_DIR_PIN, 1);
            pwm_set_enabled(STEP_PWM_SLICE, true);
            break;
        } 
        case '-': //Move motor down
        {
            gpio_put(STEP_DIR_PIN, 0);
            pwm_set_enabled(STEP_PWM_SLICE, true);
            break;
        } 
        case 'x': //Stop Motor 
        {
            pwm_set_enabled(STEP_PWM_SLICE, false);
            break;
        } 

        case 'v': //SetMotor Speed
        {
            int speed = getchar_timeout_us(10000);
            if (speed!=PICO_ERROR_TIMEOUT)
            {
                g_step_pwm_cycle_time = map(speed,90,50,1000,4000);
                pwm_set_wrap(STEP_PWM_SLICE, g_step_pwm_cycle_time);
                //printf("Speed Set to: %d \n,", g_step_pwm_cycle_time);
            }
            break;
        } 
        case 't': //tare linear encoder
        {
            g_zero_position_counts = quadrature_encoder_get_count(ENCODER_PIO, ENCODER_SM);
            break;
        } 
        case 'e': //Quit
        {
            pwm_set_enabled(STEP_PWM_SLICE, false);
            state = STATE_IDLE;
            printf("Quitting\n");
            break;
        }
        default:
        {
           
        }
    }
        
}