/**
Compression Rig Firmware.
This firware uses modified example codes from the raspberry pi pico git, refer bellow
https://github.com/raspberrypi/pico-examples/tree/master/pio/quadrature_encoder
https://github.com/raspberrypi/pico-examples/blob/master/uart/uart_advanced/uart_advanced.c
 */

//Header Files
#include <stdio.h>
#include "pico/stdlib.h"
#include "pico/multicore.h"
#include "hardware/pio.h"
#include "hardware/timer.h"
#include "hardware/uart.h"
#include "hardware/irq.h"
#include "hardware/pwm.h"
#include "pico/time.h"
#include "main.h"

// Header files generated by CMakeLists
#include "quadrature_encoder.pio.h"


//Global Variables 
//The force is written by core1 and read by core0,
//Seems to work fine for now, this is happening frequently and potentially could cause issues TODO: setup queue 
char force_string[8];
float force;
int zero_position_counts;
int step_pwm_cycle_time;



//Main Entry Point, Core 0
int main() {

    //Quadrature Encoding PIO setup
    // Base pin to connect the A phase of the encoder.
    // The B phase must be connected to the next pin
    uint offset = pio_add_program(ENCODER_PIO, &quadrature_encoder_program);
    quadrature_encoder_program_init(ENCODER_PIO, ENCODER_SM, offset, ENCODER_PIN_AB, 0);

    //USB Serial setup 
    stdio_init_all();

    //Setup Stepper
    gpio_set_function(STEP_PULSE_PIN, GPIO_FUNC_PWM);
    pwm_set_wrap(STEP_PWM_SLICE, step_pwm_cycle_time);
    pwm_set_chan_level(STEP_PWM_SLICE, STEP_PWM_CHANNEL, STEP_PULSE_PWN_WIDTH);
    pwm_set_clkdiv(STEP_PWM_SLICE,STEP_PULSE_PWM_CLKDIV);

    gpio_init(STEP_DIR_PIN);
    gpio_set_dir(STEP_DIR_PIN, GPIO_OUT);

    gpio_init(STEP_EN_PIN);
    gpio_set_dir(STEP_EN_PIN, GPIO_OUT);
    gpio_put(STEP_EN_PIN, 0);

    //multicore_reset_core1();
    multicore_launch_core1(core1_main);
    sleep_ms(1000);



    while (1) 
    {
        //wait for PC Connection
        while (!stdio_usb_connected())
        {
            tight_loop_contents();
        }
        
        //Wait for command from PC
        sleep_ms(10);
        int command = getchar_timeout_us(1000);
        if (command != PICO_ERROR_TIMEOUT)
        {
            commandHandler(command);
        }

        //Continually send force and position data to app
        outputValues(0,0);
        sleep_ms(100);
    }

}

//Core 1 Entry point
//Core 1 will handle to UART interface between the Load Cells 
void core1_main() {

    //Uart1 Setup
    uart_init(uart1, 9600);
    gpio_set_function(HARD_UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(HARD_UART_RX_PIN, GPIO_FUNC_UART);
    uart_set_fifo_enabled(uart1, false);
    // Set up a RX interrupt
    int UART_IRQ = UART1_IRQ;
    irq_set_exclusive_handler(UART_IRQ, on_uart1_rx);
    irq_set_enabled(UART_IRQ, true);
    uart_set_irq_enables(uart1, true, false);

    while (1)
    {
        tight_loop_contents();

    }
        
}

// RX1 interrupt handler
void on_uart1_rx() 
{

    //check for data on  rx buffer
    while (uart_is_readable(uart1)) {

        //get character from buffer, wait for '\n' to signify start of force number.
        uint8_t ch = uart_getc(uart1);
        if (ch == '\n')
        {
            //ignore the first 5 chars, we dont need this data
            for (int i = 0; i < 6; i++)
            {
                ch = uart_getc(uart1);
            }
            //get 7 charcters of force data 
            //ch = uart_getc(uart1);
            for (int i = 0; i < 8; i++)
            {
                force_string[i] = ch;
                ch = uart_getc(uart1);
            }
            
        }

    }

    //convert force string to float
    sscanf(force_string,"%f", &force);

}


//Map Function
//used to map value to a new range
long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

//Start Test Function. 
//Main process for the compression rig testing
void start_test(double preload, double load)
{
    //Setup Timer
    absolute_time_t start_time = get_absolute_time();
    uint32_t start_time_ms = to_ms_since_boot(start_time);
    absolute_time_t now;
    uint32_t now_ms;
    uint32_t preload_start_time;
    uint32_t preload_delay = 10000;
    uint32_t load_start_time;
    uint32_t load_delay = 2000;

    //Start Motor Down
    pwm_set_wrap(STEP_PWM_SLICE, 65535);
    gpio_put(STEP_DIR_PIN, 0);
    pwm_set_enabled(STEP_PWM_SLICE, true);

    while (1)
    {
        //get current time
        now = get_absolute_time();
        now_ms = to_ms_since_boot(now);

        outputValues(now_ms-start_time_ms, 1);

        if (getchar_timeout_us(10) == 'q') 
        {
            //Quit Test if requested
            pwm_set_enabled(STEP_PWM_SLICE, false);
            break;
        }

        //Check force, stop motor if reached preload, start timer
        if (force*1000>=preload)
        {
            //Stop Motor
            pwm_set_enabled(STEP_PWM_SLICE, false);
            preload_start_time = now_ms;

            //wait for preload timer to elaps, continue logging outputs
            while ((now_ms-preload_start_time) < preload_delay)
            {
                //Log outputs
                now = get_absolute_time();
                now_ms = to_ms_since_boot(now); 
                outputValues(now_ms-start_time_ms, 1);
            }

            //Continue Motor until peak force is reached
            pwm_set_enabled(STEP_PWM_SLICE, true); 
            while (force*1000 < load)
            {
                //Log outputs
                now = get_absolute_time();
                now_ms = to_ms_since_boot(now); 
                outputValues(now_ms-start_time_ms, 1);
            }

            //Stop Motor
            pwm_set_enabled(STEP_PWM_SLICE, false);
            //once peak force is reached delay for 2 seconds then back off
            while ((now_ms-load_start_time) < load_delay)
            {
                //Log outputs
                now = get_absolute_time();
                now_ms = to_ms_since_boot(now); 
                outputValues(now_ms-start_time_ms, 1);
            }

            //Move Motor Up
            gpio_put(STEP_DIR_PIN, 1);
            pwm_set_enabled(STEP_PWM_SLICE, true);

            while (force*1000 > 50)
            {
                //Log outputs
                now = get_absolute_time();
                now_ms = to_ms_since_boot(now); 
                outputValues(now_ms-start_time_ms, 1);
            }

            //Stop Motor
            gpio_put(STEP_DIR_PIN, 1);
            pwm_set_enabled(STEP_PWM_SLICE, false);

        }
            
        
    }
}

//Output Values
//Function to send Time, Position and Force over serial to the app.
//Function inputs are "time" which is the time to send and 
//"testRunning" booleen which is weather the test is currently running, the app will handle values differently if it is running vs not.
void outputValues(uint32_t time, bool testRunning)
{
        //get current position
        int position_counts = quadrature_encoder_get_count(ENCODER_PIO, ENCODER_SM);
        double position_mm=(position_counts-zero_position_counts)*0.005;

        //print time, position and force to serial
        if (testRunning)
        {
            printf("%u,", time);
            printf("%.3f,", position_mm);
            printf("%.3f\n",force*1000);
        }
        else
        {
            printf("$d%.3f", position_mm);
            sleep_ms(20);//add a small delay between sending so the app reads them seprately. A bit lazy.
            printf("$f%.3f",force*1000);
        }

}

// PC Command Handler
void commandHandler(int ch) 
{
    switch (ch)
    {
        case 's':
        {
            // Start Test
            
            char preloadArr[6];
            float preload;
            char loadArr[6];
            float load;

            //need to wait for data to be sent
            sleep_ms(1000);

            //First get preload value
            for (int i = 0; i < 6; i++)
            {
                preloadArr[i]= getchar();
                //Getting garbage sometimes, only want number or period
                while ((preloadArr[i] < '0' && preloadArr[i]!= '.') || preloadArr[i] > '9' )
                {
                    preloadArr[i]= getchar();
                    
                    if (preloadArr[i]=PICO_ERROR_TIMEOUT)
                    {
                        break;
                    }
                }
            }

            //Then get load value
            for (int i = 0; i < 6; i++)
            {
                loadArr[i]= getchar();
                //Getting garbage sometimes, only want number or period
                while ((loadArr[i] < '0'&& loadArr[i]!= '.')  || loadArr[i] > '9')
                {
                    loadArr[i]= getchar();
                    if (loadArr[i]=PICO_ERROR_TIMEOUT)
                    {
                        break;
                    }
                }
            }

            sscanf(preloadArr,"%f", &preload);
            sscanf(loadArr,"%f", &load);

            printf("PreLoad Set to: %.1f N,", preload);
            printf("\n");
            printf("Load Set to: %.1f N,", load);
            printf("\n");

            //Delay 2 seconds before starting 
            sleep_ms(2000);

            start_test(preload, load);

            break;
        }

        case 'u':
        {
            //Motor move up
            gpio_put(STEP_DIR_PIN, 1);
            pwm_set_enabled(STEP_PWM_SLICE, true);
            break;

        } 
        case 'd':
        {
            //Motor move down
            gpio_put(STEP_DIR_PIN, 0);
            pwm_set_enabled(STEP_PWM_SLICE, true);
            break;
        } 

        case 'x':
        {
            //Stop Motor Movement
            pwm_set_enabled(STEP_PWM_SLICE, false);
            break;
        } 

        case 'v':
        {
            //Change Motor Speed
            int speed = getchar_timeout_us(10000);
            if (speed!=PICO_ERROR_TIMEOUT)
            {
                step_pwm_cycle_time = map(speed,90,50,1000,65535);
                pwm_set_wrap(STEP_PWM_SLICE, step_pwm_cycle_time);
            }
            break;

        } 
        case 't':
        {
            //tare linear encoder
            zero_position_counts = quadrature_encoder_get_count(ENCODER_PIO, ENCODER_SM);
        } 
        default:
        {
           
        }
    }
        
}